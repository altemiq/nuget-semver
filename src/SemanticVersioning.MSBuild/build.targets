<?xml version="1.0" encoding="utf-8"?>
<Project>

  <PropertyGroup>
    <SemanticVersion_IsOuterBuild Condition=" '$(SemanticVersion_IsOuterBuild)' == '' ">false</SemanticVersion_IsOuterBuild>

    <!-- Use DispatchToInnerBuilds if a multi-targetedBuild -->
    <SemanticVersion_BeforeTargets>CoreCompile</SemanticVersion_BeforeTargets>
    <SemanticVersion_BeforeTargets Condition="$(SemanticVersion_IsOuterBuild)">DispatchToInnerBuilds</SemanticVersion_BeforeTargets>

    <!-- to prevent targets from being run extra times,
         enforce that only the outer build of a multi-targeted
         project or a single-targeted build can run -->
    <SemanticVersion_ShouldRunTarget>false</SemanticVersion_ShouldRunTarget>
    <SemanticVersion_ShouldRunTarget Condition=" '$(TargetFrameworks)' == '' or $(SemanticVersion_IsOuterBuild) ">true</SemanticVersion_ShouldRunTarget>
    
    <!-- disable when this is not packable,
         and we only want to compute packable versions -->
    <SemanticVersion_ShouldRunTarget Condition=" '$(OnlyComputeSemanticVersionForPackable)' == 'true' and '$(IsPackable)' != 'true' ">false</SemanticVersion_ShouldRunTarget>
  </PropertyGroup>

  <!-- Get the semantic version from the latest package and commit -->
  <Target Name="GetSemanticVersion"
          BeforeTargets="$(SemanticVersion_BeforeTargets)"
          Condition=" '$(SemanticVersion_ShouldRunTarget)' == 'true' and '$(SourceControlInformationFeatureSupported)' == 'true' and '$(DisableSemanticVersioning)' != 'true' and '$(ComputeSemanticVersion)' == 'true' ">

    <!-- Set the project NAME/DIR/PATH properties
         These are not available before DispatchToInnerBuilds
         so we need to use the well known properties -->
    <PropertyGroup>
      <SemanticVersion_ProjectName>$(ProjectName)</SemanticVersion_ProjectName>
      <SemanticVersion_ProjectName Condition=" '$(SemanticVersion_ProjectName)' == '' ">$(MSBuildProjectName)</SemanticVersion_ProjectName>
      <SemanticVersion_ProjectDir>$(ProjectDir)</SemanticVersion_ProjectDir>
      <SemanticVersion_ProjectDir Condition=" '$(SemanticVersion_ProjectDir)' == '' ">$(MSBuildProjectDirectory)</SemanticVersion_ProjectDir>
      <SemanticVersion_ProjectPath>$(ProjectPath)</SemanticVersion_ProjectPath>
      <SemanticVersion_ProjectPath Condition=" '$(SemanticVersion_ProjectPath)' == '' ">$(MSBuildProjectFullPath)</SemanticVersion_ProjectPath>
      <SemanticVersionOutputPath Condition=" '$(SemanticVersionOutputPath)' == '' ">$(IntermediateOutputPath)</SemanticVersionOutputPath>
      <SemanticVersionOutputPath>$([MSBuild]::EnsureTrailingSlash('$(SemanticVersionOutputPath)'))</SemanticVersionOutputPath>
      <_VersionsFromFile>false</_VersionsFromFile>
    </PropertyGroup>

    <!-- set the version file -->
    <ItemGroup>
      <SemanticVersion_VersionFile Include="$(SemanticVersionOutputPath)$(SemanticVersion_ProjectName).version.txt" />
    </ItemGroup>

    <ReadVersionFromFile File="@(SemanticVersion_VersionFile)">
      <Output TaskParameter="Version" PropertyName="_VersionFromFile" />
      <Output TaskParameter="VersionPrefix" PropertyName="_VersionPrefixFromFile" />
      <Output TaskParameter="VersionSuffix" PropertyName="_VersionSuffixFromFile" />
      <Output TaskParameter="RepositoryCommit" PropertyName="_RepositoryCommitFromFile" />
    </ReadVersionFromFile>

    <!-- Get the commits for the project
         This returns the specified maximum.
         The latest package should be within the
         maximum count to be able to be found -->
    <GetProjectCommitsTask
      ProjectDir="$(SemanticVersion_ProjectDir)"
      MaxCount="$(MaxCommitCount)">
      <Output TaskParameter="Commits" PropertyName="_RepositoryCommits"/>
      <Output TaskParameter="Commit" PropertyName="_RepositoryCommit"/>
    </GetProjectCommitsTask>

    <PropertyGroup Condition=" '$(_RepositoryCommit)' == '$(_RepositoryCommitFromFile)'">
      <_VersionsFromFile>true</_VersionsFromFile>
      <_ComputedVersion>$(_VersionFromFile)</_ComputedVersion>
      <_ComputedVersionPrefix>$(_VersionPrefixFromFile)</_ComputedVersionPrefix>
      <_ComputedVersionSuffix>$(_VersionSuffixFromFile)</_ComputedVersionSuffix>
      <_RepositoryCommit>$(_RepositoryCommitFromFile)</_RepositoryCommit>
    </PropertyGroup>

    <Message Text="$(SemanticVersion_ProjectName) -> Commits: $(_RepositoryCommits)"
             Importance="Normal" />
    <Message Text="$(SemanticVersion_ProjectName) -> Commit: $(_RepositoryCommit)"
             Importance="Normal" />

    <!-- Get the head commits for the repository
         We can use this to see if a package has
         a newer commit than the project commit -->
    <GetHeadCommitsTask
      ProjectDir="$(SemanticVersion_ProjectDir)"
      ProjectCommit="$(_RepositoryCommit)"
      MaxCount="$(MaxCommitCount)"
      Condition="!$(_VersionsFromFile)">
      <Output TaskParameter="Commits" PropertyName="_HeadCommits" />
    </GetHeadCommitsTask>

    <Message Text="$(SemanticVersion_ProjectName) -> Head Commits: $(_HeadCommits)"
             Condition=" '$(_HeadCommits)' != '' "
             Importance="Normal" />

    <!-- Get the referenced project for the current project
         This means we can check to see if any referenced projects
         have a new commit -->
    <GetReferencedProjectsTask
      ProjectPath="$(SemanticVersion_ProjectPath)"
      Condition="!$(_VersionsFromFile)">
      <Output TaskParameter="ReferencedProjectDirs" ItemName="_ReferencedProjectDirs" />
    </GetReferencedProjectsTask>

    <!-- Get the latest commit for the referenced projects -->
    <GetLatestCommitTask
      Paths="@(_ReferencedProjectDirs)"
      Condition="!$(_VersionsFromFile)">
      <Output TaskParameter="Commit" PropertyName="_ReferenceCommit" />
    </GetLatestCommitTask>

    <Message Text="$(SemanticVersion_ProjectName) -> Reference Commit: $(_ReferenceCommit)"
             Condition=" '$(_ReferenceCommit)' != '' "
             Importance="Normal" />

    <!-- Set the version repository branch to use -->
    <PropertyGroup>
      <VersionRepositoryBranch Condition=" '$(VersionRepositoryBranch)' == '' ">$(RepositoryBranch)</VersionRepositoryBranch>
    </PropertyGroup>

    <!-- Get the branch name if we haven't got it already -->
    <GetBranchNameTask
      ProjectDir="$(SemanticVersion_ProjectDir)"
      Condition=" '$(VersionRepositoryBranch)' == '' and !$(_VersionsFromFile)">
      <Output TaskParameter="Branch" PropertyName="VersionRepositoryBranch" />
    </GetBranchNameTask>

    <!-- Set the output target folder, restore source, and whether we should calculate the version suffix -->
    <PropertyGroup>
      <VersionBuildOutputTargetFolder Condition=" '$(VersionBuildOutputTargetFolder)' == '' ">$(BuildOutputTargetFolder)</VersionBuildOutputTargetFolder>
      <VersionRestoreSources Condition=" '$(VersionRestoreSources)' == '' ">$(RestoreSources)</VersionRestoreSources>
      <NoVersionSuffix Condition=" '$(NoVersionSuffix)' == '' and '$(VersionRepositoryBranch)' == '$(DefaultRepositoryBranch)' ">true</NoVersionSuffix>
    </PropertyGroup>

    <!-- Calculate the target extension -->
    <PropertyGroup>
      <SemanticVersion_TargetExt>$(TargetExt)</SemanticVersion_TargetExt>
      <SemanticVersion_TargetExt Condition=" '$(SemanticVersion_TargetExt)' == '' and '$(OutputType)'=='exe'">.exe</SemanticVersion_TargetExt>
      <SemanticVersion_TargetExt Condition=" '$(SemanticVersion_TargetExt)' == '' and '$(OutputType)'=='winexe'">.exe</SemanticVersion_TargetExt>
      <SemanticVersion_TargetExt Condition=" '$(SemanticVersion_TargetExt)' == '' and '$(OutputType)'=='appcontainerexe'">.exe</SemanticVersion_TargetExt>
      <SemanticVersion_TargetExt Condition=" '$(SemanticVersion_TargetExt)' == '' and '$(OutputType)'=='library'">.dll</SemanticVersion_TargetExt>
      <SemanticVersion_TargetExt Condition=" '$(SemanticVersion_TargetExt)' == '' and '$(OutputType)'=='module'">.netmodule</SemanticVersion_TargetExt>
      <SemanticVersion_TargetExt Condition=" '$(SemanticVersion_TargetExt)' == '' and '$(OutputType)'=='winmdobj'">.winmdobj</SemanticVersion_TargetExt>
    </PropertyGroup>

    <!-- Calculate the semantic version -->
    <SemanticVersioningTask
      ProjectDir="$(SemanticVersion_ProjectDir)"
      AssemblyName="$(AssemblyName)"
      PackageId="$(PackageId)"
      TargetExt="$(SemanticVersion_TargetExt)"
      BuildOutputTargetFolder="$(VersionBuildOutputTargetFolder)"
      OutputPath="$(OutputPath)"
      RestoreSources="$(VersionRestoreSources)"
      PackageIdRegex="$(PackageIdRegex)"
      PackageIdReplace="$(PackageIdReplace)"
      Previous="$(Previous)"
      NoCache="$(NoCache)"
      DirectDownload="$(DirectDownload)"
      NoVersionSuffix="$(NoVersionSuffix)"
      VersionSuffix="$(VersionRepositoryBranch)"
      Commits="$(_RepositoryCommits)"
      HeadCommits="$(_HeadCommits)"
      ReferenceCommit="$(_ReferenceCommit)"
      Condition="!$(_VersionsFromFile)">
      <Output TaskParameter="ComputedVersion" PropertyName="_ComputedVersion" />
      <Output TaskParameter="ComputedVersionPrefix" PropertyName="_ComputedVersionPrefix" />
      <Output TaskParameter="ComputedVersionSuffix" PropertyName="_ComputedVersionSuffix" />
    </SemanticVersioningTask>

    <PropertyGroup>
      <!-- set the properties for the version -->
      <Version Condition=" $(ForceSemanticVersion) Or '$(Version)' == '' ">$(_ComputedVersion)</Version>
      <VersionPrefix Condition=" $(ForceSemanticVersion) Or '$(VersionPrefix)' == '' ">$(_ComputedVersionPrefix)</VersionPrefix>
      <VersionSuffix Condition=" $(ForceSemanticVersion) Or '$(VersionSuffix)' == '' ">$(_ComputedVersionSuffix)</VersionSuffix>
      <PackageVersion Condition=" $(ForceSemanticVersion) Or '$(PackageVersion)' == '' ">$(_ComputedVersion)</PackageVersion>
      <RepositoryCommit Condition=" $(ForceSemanticVersion) Or '$(RepositoryCommit)' != '' ">$(_RepositoryCommit)</RepositoryCommit>

      <!-- create a properties property to hold the values for the inner build projects -->
      <_Properties Condition=" '$(Version)' != '' ">$(_Properties);Version=$(Version)</_Properties>
      <_Properties Condition=" '$(VersionPrefix)' != '' ">$(_Properties);VersionPrefix=$(VersionPrefix)</_Properties>
      <_Properties Condition=" '$(VersionSuffix)' != '' ">$(_Properties);VersionSuffix=$(VersionSuffix)</_Properties>
      <_Properties Condition=" '$(PackageVersion)' != '' ">$(_Properties);PackageVersion=$(PackageVersion)</_Properties>
      <_Properties Condition=" '$(RepositoryCommit)' != '' ">$(_Properties);RepositoryCommit=$(RepositoryCommit)</_Properties>
    </PropertyGroup>

    <ItemGroup>
      <_InnerBuildProjects>
        <Properties>$(Properties);$(_Properties)</Properties>
      </_InnerBuildProjects>
    </ItemGroup>

    <Message Text="$(SemanticVersion_ProjectName) -> Version: $(Version), VersionPrefix: $(VersionPrefix), VersionSuffix: $(VersionSuffix), RepositoryCommit: $(RepositoryCommit)"
             Importance="High" />

    <WriteVersionToFile File="@(SemanticVersion_VersionFile)"
                        Condition="!$(_VersionsFromFile)"
                        Version="$(Version)"
                        VersionPrefix="$(VersionPrefix)"
                        VersionSuffix="$(VersionSuffix)"
                        RepositoryCommit="$(RepositoryCommit)"
                        Overwrite="true" />

    <ItemGroup>
      <FileWrites Include="@(SemanticVersion_VersionFile)" />
    </ItemGroup>

  </Target>

</Project>